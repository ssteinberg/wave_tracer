/*
*
* wave tracer
* Copyright  Shlomi Steinberg
*
* LICENSE: Creative Commons Attribution-NonCommercial 4.0 International
*
*/

#include <sys/ioctl.h>
#include <optional>

#include <vector>
#include <string>
#include <iostream>

#include <wt/util/logger/logger.hpp>
#include <wt/util/logger/progressbar.hpp>
#include <wt/util/logger/termcolor.hpp>


using namespace wt;
using namespace logger;


namespace wt::logger {

thread_local logger_t::osyncstreams_t logger_t::sss;

logger_t cout(std::cout);
logger_t cwarn(std::cerr, colour::magenta, font_style::italic);
logger_t cerr(std::cerr, colour::red, font_style::bold);

}



//
// most of indicators namespace is copied from github.com/p-ranav/indicators by Pranav
// (MIT)
// with very minor modifications
//

namespace indicators {


namespace _detail {

inline std::pair<size_t, size_t> terminal_size() {
    struct winsize size{};
    ioctl(STDOUT_FILENO, TIOCGWINSZ, &size);
    return {static_cast<size_t>(size.ws_row), static_cast<size_t>(size.ws_col)};
}
inline size_t terminal_width() { return terminal_size().second; }

struct interval {
    int first;
    int last;
};
/* auxiliary function for binary search in interval table */
inline int bisearch(wchar_t ucs, const struct interval *table, int max) {
    int min = 0;
    int mid;

    if (ucs < table[0].first || ucs > table[max].last)
        return 0;
    while (max >= min) {
        mid = (min + max) / 2;
        if (ucs > table[mid].last)
            min = mid + 1;
        else if (ucs < table[mid].first)
            max = mid - 1;
        else
            return 1;
    }

    return 0;
}

/* The following two functions define the column width of an ISO 10646
 * character as follows:
 *
 *    - The null character (U+0000) has a column width of 0.
 *
 *    - Other C0/C1 control characters and DEL will lead to a return
 *      value of -1.
 *
 *    - Non-spacing and enclosing combining characters (general
 *      category code Mn or Me in the Unicode database) have a
 *      column width of 0.
 *
 *    - SOFT HYPHEN (U+00AD) has a column width of 1.
 *
 *    - Other format characters (general category code Cf in the Unicode
 *      database) and ZERO WIDTH SPACE (U+200B) have a column width of 0.
 *
 *    - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)
 *      have a column width of 0.
 *
 *    - Spacing characters in the East Asian Wide (W) or East Asian
 *      Full-width (F) category as defined in Unicode Technical
 *      Report #11 have a column width of 2.
 *
 *    - All remaining characters (including all printable
 *      ISO 8859-1 and WGL4 characters, Unicode control characters,
 *      etc.) have a column width of 1.
 *
 * This implementation assumes that wchar_t characters are encoded
 * in ISO 10646.
 */

inline int mk_wcwidth(wchar_t ucs) {
    /* sorted list of non-overlapping intervals of non-spacing characters */
    /* generated by "uniset +cat=Me +cat=Mn +cat=Cf -00AD +1160-11FF +200B c" */
    static const struct interval combining[] = {
            {0x0300, 0x036F},   {0x0483, 0x0486},   {0x0488, 0x0489},
            {0x0591, 0x05BD},   {0x05BF, 0x05BF},   {0x05C1, 0x05C2},
            {0x05C4, 0x05C5},   {0x05C7, 0x05C7},   {0x0600, 0x0603},
            {0x0610, 0x0615},   {0x064B, 0x065E},   {0x0670, 0x0670},
            {0x06D6, 0x06E4},   {0x06E7, 0x06E8},   {0x06EA, 0x06ED},
            {0x070F, 0x070F},   {0x0711, 0x0711},   {0x0730, 0x074A},
            {0x07A6, 0x07B0},   {0x07EB, 0x07F3},   {0x0901, 0x0902},
            {0x093C, 0x093C},   {0x0941, 0x0948},   {0x094D, 0x094D},
            {0x0951, 0x0954},   {0x0962, 0x0963},   {0x0981, 0x0981},
            {0x09BC, 0x09BC},   {0x09C1, 0x09C4},   {0x09CD, 0x09CD},
            {0x09E2, 0x09E3},   {0x0A01, 0x0A02},   {0x0A3C, 0x0A3C},
            {0x0A41, 0x0A42},   {0x0A47, 0x0A48},   {0x0A4B, 0x0A4D},
            {0x0A70, 0x0A71},   {0x0A81, 0x0A82},   {0x0ABC, 0x0ABC},
            {0x0AC1, 0x0AC5},   {0x0AC7, 0x0AC8},   {0x0ACD, 0x0ACD},
            {0x0AE2, 0x0AE3},   {0x0B01, 0x0B01},   {0x0B3C, 0x0B3C},
            {0x0B3F, 0x0B3F},   {0x0B41, 0x0B43},   {0x0B4D, 0x0B4D},
            {0x0B56, 0x0B56},   {0x0B82, 0x0B82},   {0x0BC0, 0x0BC0},
            {0x0BCD, 0x0BCD},   {0x0C3E, 0x0C40},   {0x0C46, 0x0C48},
            {0x0C4A, 0x0C4D},   {0x0C55, 0x0C56},   {0x0CBC, 0x0CBC},
            {0x0CBF, 0x0CBF},   {0x0CC6, 0x0CC6},   {0x0CCC, 0x0CCD},
            {0x0CE2, 0x0CE3},   {0x0D41, 0x0D43},   {0x0D4D, 0x0D4D},
            {0x0DCA, 0x0DCA},   {0x0DD2, 0x0DD4},   {0x0DD6, 0x0DD6},
            {0x0E31, 0x0E31},   {0x0E34, 0x0E3A},   {0x0E47, 0x0E4E},
            {0x0EB1, 0x0EB1},   {0x0EB4, 0x0EB9},   {0x0EBB, 0x0EBC},
            {0x0EC8, 0x0ECD},   {0x0F18, 0x0F19},   {0x0F35, 0x0F35},
            {0x0F37, 0x0F37},   {0x0F39, 0x0F39},   {0x0F71, 0x0F7E},
            {0x0F80, 0x0F84},   {0x0F86, 0x0F87},   {0x0F90, 0x0F97},
            {0x0F99, 0x0FBC},   {0x0FC6, 0x0FC6},   {0x102D, 0x1030},
            {0x1032, 0x1032},   {0x1036, 0x1037},   {0x1039, 0x1039},
            {0x1058, 0x1059},   {0x1160, 0x11FF},   {0x135F, 0x135F},
            {0x1712, 0x1714},   {0x1732, 0x1734},   {0x1752, 0x1753},
            {0x1772, 0x1773},   {0x17B4, 0x17B5},   {0x17B7, 0x17BD},
            {0x17C6, 0x17C6},   {0x17C9, 0x17D3},   {0x17DD, 0x17DD},
            {0x180B, 0x180D},   {0x18A9, 0x18A9},   {0x1920, 0x1922},
            {0x1927, 0x1928},   {0x1932, 0x1932},   {0x1939, 0x193B},
            {0x1A17, 0x1A18},   {0x1B00, 0x1B03},   {0x1B34, 0x1B34},
            {0x1B36, 0x1B3A},   {0x1B3C, 0x1B3C},   {0x1B42, 0x1B42},
            {0x1B6B, 0x1B73},   {0x1DC0, 0x1DCA},   {0x1DFE, 0x1DFF},
            {0x200B, 0x200F},   {0x202A, 0x202E},   {0x2060, 0x2063},
            {0x206A, 0x206F},   {0x20D0, 0x20EF},   {0x302A, 0x302F},
            {0x3099, 0x309A},   {0xA806, 0xA806},   {0xA80B, 0xA80B},
            {0xA825, 0xA826},   {0xFB1E, 0xFB1E},   {0xFE00, 0xFE0F},
            {0xFE20, 0xFE23},   {0xFEFF, 0xFEFF},   {0xFFF9, 0xFFFB},
            {0x10A01, 0x10A03}, {0x10A05, 0x10A06}, {0x10A0C, 0x10A0F},
            {0x10A38, 0x10A3A}, {0x10A3F, 0x10A3F}, {0x1D167, 0x1D169},
            {0x1D173, 0x1D182}, {0x1D185, 0x1D18B}, {0x1D1AA, 0x1D1AD},
            {0x1D242, 0x1D244}, {0xE0001, 0xE0001}, {0xE0020, 0xE007F},
            {0xE0100, 0xE01EF}};

    /* test for 8-bit control characters */
    if (ucs == 0)
        return 0;
    if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0))
        return -1;

    /* binary search in table of non-spacing characters */
    if (bisearch(ucs, combining, sizeof(combining) / sizeof(struct interval) - 1))
        return 0;

    /* if we arrive here, ucs is not a combining or C0/C1 control character */

    return 1 +
                 (ucs >= 0x1100 &&
                 (ucs <= 0x115f || /* Hangul Jamo init. consonants */
                  ucs == 0x2329 || ucs == 0x232a ||
                  (ucs >= 0x2e80 && ucs <= 0xa4cf && ucs != 0x303f) || /* CJK ... Yi */
                  (ucs >= 0xac00 && ucs <= 0xd7a3) || /* Hangul Syllables */
                  (ucs >= 0xf900 && ucs <= 0xfaff) || /* CJK Compatibility Ideographs */
                  (ucs >= 0xfe10 && ucs <= 0xfe19) || /* Vertical forms */
                  (ucs >= 0xfe30 && ucs <= 0xfe6f) || /* CJK Compatibility Forms */
                  (ucs >= 0xff00 && ucs <= 0xff60) || /* Fullwidth Forms */
                  (ucs >= 0xffe0 && ucs <= 0xffe6) ||
                  (ucs >= 0x20000 && ucs <= 0x2fffd) ||
                  (ucs >= 0x30000 && ucs <= 0x3fffd)));
}

inline int mk_wcswidth(const wchar_t *pwcs, size_t n) {
    int w, width = 0;

    for (; *pwcs && n-- > 0; pwcs++)
        if ((w = mk_wcwidth(*pwcs)) < 0)
            return -1;
        else
            width += w;

    return width;
}

inline std::wstring utf8_decode(const std::string& s) {
    auto r = setlocale(LC_ALL, "");
    std::string curLocale;
    if (r)
      curLocale = r;
    const char* _Source = s.c_str();
    size_t _Dsize = mbstowcs(NULL, _Source, 0) + 1;
    wchar_t* _Dest = new wchar_t[_Dsize];
    wmemset(_Dest, 0, _Dsize);
    mbstowcs(_Dest, _Source, _Dsize);
    std::wstring result = _Dest;
    delete[] _Dest;
    setlocale(LC_ALL, curLocale.c_str());
    return result;
}

inline int display_width(const std::string &input) {
    return mk_wcswidth(utf8_decode(input).c_str(), input.size());
}

inline int display_width(const std::wstring &input) {
    return mk_wcswidth(input.c_str(), input.size());
}

inline std::ostream& write_duration(std::ostream &os, std::chrono::nanoseconds ns) {
    using namespace std;
    using namespace std::chrono;
    using days = duration<int, ratio<86400>>;
    char fill = os.fill();
    os.fill('0');
    auto d = duration_cast<days>(ns);
    ns -= d;
    auto h = duration_cast<hours>(ns);
    ns -= h;
    auto m = duration_cast<minutes>(ns);
    ns -= m;
    auto s = duration_cast<seconds>(ns);
    if (d.count() > 0)
        os << setw(2) << d.count() << "d:";
    if (h.count() > 0)
        os << setw(2) << h.count() << "h:";
    os << setw(2) << m.count() << "m:" << setw(2) << s.count() << 's';
    os.fill(fill);
    return os;
}

}

class block_progress_scale_writer {
public:
    block_progress_scale_writer(std::ostream &os, size_t bar_width) : os(os), bar_width(bar_width) {}

    std::ostream &write(float progress) {
        std::string fill_text{"█"};
        std::vector<std::string> lead_characters{" ", "▏", "▎", "▍", "▌", "▋", "▊", "▉"};
        auto value = (std::min)(1.0f, (std::max)(0.0f, progress));
        auto whole_width = std::floor(value * bar_width);
        auto remainder_width = fmod((value * bar_width), 1.0f);
        auto part_width = std::floor(remainder_width * lead_characters.size());
        std::string lead_text = lead_characters[size_t(part_width)];
        if ((bar_width - whole_width - 1) < 0)
            lead_text = "";
        for (size_t i = 0; i < whole_width; ++i)
            os << fill_text;
        os << lead_text;
        for (size_t i = 0; i < (bar_width - whole_width - 1); ++i)
            os << " ";
        return os;
    }

private:
    std::ostream &os;
    size_t bar_width = 0;
};

}


using namespace wt::logger::indicators;

block_progress_bar_t::block_progress_bar_t(
        colour foreground_colour,
        std::optional<font_style> style,
        std::uint32_t barwidth,
        bool show_percentage,
        bool show_elapsed_time,
        bool show_remaining_time,
        std::string prefix,
        std::string postfix,
        std::string start,
        std::string end)
    : foreground_colour(foreground_colour),
      style(style),
      barwidth(barwidth),
      show_percentage(show_percentage),
      show_elapsed_time(show_elapsed_time),
      show_remaining_time(show_remaining_time),
      prefix(std::move(prefix)),
      postfix(std::move(postfix)),
      start(std::move(start)),
      end(std::move(end))
{}

std::pair<std::string, int> block_progress_bar_t::get_prefix_text() const {
    std::stringstream os;
    os << prefix;
    const auto result = std::move(os).str();
    const auto result_size = ::indicators::_detail::display_width(result);
    return {result, result_size};
}

std::pair<std::string, int> block_progress_bar_t::get_postfix_text() const {
    std::stringstream os;
    auto now = std::chrono::high_resolution_clock::now();
    auto elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(now - start_time_point_);

    if (show_percentage) {
        os << " " << (std::min)(static_cast<size_t>(progress_ / max_progress * 100.f), size_t(100)) << "%";
    }

    if (show_elapsed_time) {
        os << " [";
        if (saved_start_time)
        ::indicators::_detail::write_duration(os, elapsed);
        else
        os << "00:00s";
    }

    if (show_remaining_time) {
        if (show_elapsed_time)  os << "<";
        else                    os << " [";

        if (saved_start_time) {
            auto eta = std::chrono::nanoseconds(
                progress_ > 0
                    ? static_cast<long long>(std::ceil(float(elapsed.count()) *
                                                        max_progress / progress_))
                    : 0);
            auto remaining = eta > elapsed ? (eta - elapsed) : (elapsed - eta);
            ::indicators::_detail::write_duration(os, remaining);
        } else {
            os << "00:00s";
        }
        os << "]";
    } else {
        if (show_elapsed_time)
            os << "]";
    }

    os << " " << postfix;

    const auto result = std::move(os).str();
    const auto result_size = ::indicators::_detail::display_width(result);
    return {result, result_size};
}

void block_progress_bar_t::print_progress(std::ostream* os, bool from_multi_progress) {
    // std::lock_guard<std::mutex> lock{mutex_};

    if (multi_progress_mode_ && !from_multi_progress) {
        if (progress_ >= max_progress)
            completed = true;
        return;
    }

    if (foreground_colour != colour::unspecified)
        termcolour::set_stream_colour(*os, foreground_colour);

    if (style)
        termcolour::set_font_style(*os, *style);

    const auto prefix_pair = get_prefix_text();
    const auto prefix_text = prefix_pair.first;
    const auto prefix_length = prefix_pair.second;
    *os << "\r" << prefix_text;

    *os << start;

    ::indicators::block_progress_scale_writer writer{*os, barwidth};
    writer.write(progress_ / max_progress);

    *os << end;

    const auto postfix_pair = get_postfix_text();
    const auto postfix_text = postfix_pair.first;
    const auto postfix_length = postfix_pair.second;
    *os << postfix_text;

    // Get length of prefix text and postfix text
    const auto start_length = start.size();
    const auto bar_width = barwidth;
    const auto end_length = end.size();
    const auto terminal_width = ::indicators::_detail::terminal_size().second;
    // prefix + bar_width + postfix should be <= terminal_width
    const int remaining = terminal_width - (prefix_length + start_length + bar_width + end_length + postfix_length);
    if (prefix_length == -1 || postfix_length == -1) {
        *os << "\r";
    } else if (remaining > 0) {
        *os << std::string(remaining, ' ') << "\r";
    } else if (remaining < 0) {
        // Do nothing. Maybe in the future truncate postfix with ...
    }

    if (progress_ >= max_progress)
        completed = true;

    if (completed && !from_multi_progress) // Don't std::endl if calling from MultiProgress
        *os << termcolour::reset << '\n';
}
