
.. _program_listing_file__home_runner_work_wave_tracer_wave_tracer_include_wt_bsdf_composite.hpp:

Program Listing for File composite.hpp
======================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_wave_tracer_wave_tracer_include_wt_bsdf_composite.hpp>` (``/home/runner/work/wave_tracer/wave_tracer/include/wt/bsdf/composite.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
   *
   * wave tracer
   * Copyright  Shlomi Steinberg
   *
   * LICENSE: Creative Commons Attribution-NonCommercial 4.0 International
   *
   */
   
   #pragma once
   
   #include <string>
   #include <memory>
   #include <map>
   
   #include <wt/wt_context.hpp>
   
   #include "bsdf.hpp"
   
   namespace wt::bsdf {
   
   class composite_t final : public bsdf_t {
   private:
       struct comparator_rangew_t {
           bool operator()(const auto& a, const auto& b) const {
               return a.max<=b.min;
           }
       };
   
       using map_range_t = range_t<wavenumber_t, range_inclusiveness_e::left_inclusive>;
       using map_t = std::map<map_range_t, 
                              std::shared_ptr<bsdf_t>, 
                              comparator_rangew_t>;
   
   private:
       map_t bsdfs;
       range_t<wavenumber_t> range;
   
   public:
       composite_t(std::string id, 
                   map_t bsdfs) 
           : bsdf_t(std::move(id)), 
             bsdfs(std::move(bsdfs))
       {
           this->range = range_t<wavenumber_t>::null();
           for (const auto& s : this->bsdfs) {
               assert((this->range & s.first).empty());    // overlapping spectra?
               this->range |= s.first;
           }
       }
       composite_t(composite_t&&) = default;
   
       [[nodiscard]] inline std::optional<f_t> albedo(const wavenumber_t k) const noexcept override {
           const auto it = bsdfs.lower_bound(map_range_t::range(k));
           if (it!=bsdfs.end() && it->first.contains(k))
               return it->second->albedo(k);
           return 0;
       }
       
       [[nodiscard]] lobe_mask_t lobes(wavenumber_t k) const noexcept override {
           const auto it = bsdfs.lower_bound(map_range_t::range(k));
           if (it!=bsdfs.end() && it->first.contains(k))
               return it->second->lobes(k);
           return 0;
       }
       
       [[nodiscard]] inline bool is_delta_only(wavenumber_t k) const noexcept override {
           const auto it = bsdfs.lower_bound(map_range_t::range(k));
           if (it!=bsdfs.end() && it->first.contains(k))
               return it->second->is_delta_only(k);
           return true;
       }
       
       [[nodiscard]] inline bool is_delta_lobe(wavenumber_t k, std::uint32_t lobe) const noexcept override {
           const auto it = bsdfs.lower_bound(map_range_t::range(k));
           if (it!=bsdfs.end() && it->first.contains(k))
               return it->second->is_delta_lobe(k, lobe);
           return true;
       }
   
       [[nodiscard]] bsdf_result_t f(
               const dir3_t &wi,
               const dir3_t &wo,
               const bsdf_query_t& query) const noexcept override {
           const auto k  = query.k;
           const auto it = bsdfs.lower_bound(map_range_t::range(k));
           if (it!=bsdfs.end() && it->first.contains(k))
               return it->second->f(wi,wo,query);
           return {};
       }
   
       [[nodiscard]] std::optional<bsdf_sample_t> sample(
               const dir3_t &wi,
               const bsdf_query_t& query, 
               sampler::sampler_t& sampler) const noexcept override {
           const auto k  = query.k;
           const auto it = bsdfs.lower_bound(map_range_t::range(k));
           if (it!=bsdfs.end() && it->first.contains(k))
               return it->second->sample(wi,query,sampler);
           return {};
       }
       
       [[nodiscard]] solid_angle_density_t pdf(
               const dir3_t &wi,
               const dir3_t &wo,
               const bsdf_query_t& query) const noexcept override {
           const auto k  = query.k;
           const auto it = bsdfs.lower_bound(map_range_t::range(k));
           if (it!=bsdfs.end() && it->first.contains(k))
               return it->second->pdf(wi,wo,query);
           return {};
       }
   
       [[nodiscard]] f_t eta(
               const dir3_t &wi,
               const dir3_t &wo,
               const wavenumber_t k) const noexcept override {
           const auto it = bsdfs.lower_bound(map_range_t::range(k));
           if (it!=bsdfs.end() && it->first.contains(k))
               return it->second->eta(wi,wo,k);
           return {};
       }
   
       [[nodiscard]] scene::element::info_t description() const override;
   
   public:
       static std::unique_ptr<bsdf_t> load(std::string id, scene::loader::loader_t* loader, const scene::loader::node_t& node, const wt::wt_context_t &context);
   };
   
   }
