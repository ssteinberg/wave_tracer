
.. _program_listing_file__home_runner_work_wave_tracer_wave_tracer_include_wt_math_quantity_defs.hpp:

Program Listing for File defs.hpp
=================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_wave_tracer_wave_tracer_include_wt_math_quantity_defs.hpp>` (``/home/runner/work/wave_tracer/wave_tracer/include/wt/math/quantity/defs.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
   *
   * wave tracer
   * Copyright  Shlomi Steinberg
   *
   * LICENSE: Creative Commons Attribution-NonCommercial 4.0 International
   *
   */
   
   #pragma once
   
   #include <wt/math/quantity/framework.hpp>
   #include <wt/math/defs.hpp>
   #include <wt/util/concepts.hpp>
   #include <mp-units/systems/isq/electromagnetism.h>
   
   namespace wt {
   
   namespace isq {
   using namespace mp_units::isq;
   inline constexpr auto power = mp_units::isq::electromagnetism_power;
   }
   
   namespace siconstants {
   using mp_units::si::standard_gravity;
   using mp_units::si::magnetic_constant;
   using namespace mp_units::si::si2019;
   }
   
   template <mp_units::Reference auto R, Numeric Rep=f_t>
   using quantity = mp_units::quantity<R, Rep>;
   template <mp_units::Reference auto R, mp_units::PointOrigin auto O, Numeric Rep=f_t>
   using quantity_point = mp_units::quantity_point<R, O, Rep>;
   
   using mp_units::dimensionless;
   using mp_units::delta;
   using mp_units::point;
   
   using mp_units::inverse;
   using mp_units::square;
   using mp_units::pow;
   
   namespace u {
   
   using mp_units::one;
   using namespace mp_units::si::unit_symbols;
   
   namespace ang {
   using namespace mp_units::angular::unit_symbols;
   }
   
   }
   
   namespace angular {
   using mp_units::angular::angle;
   using mp_units::angular::solid_angle;
   }
   
   // EM quantity specs
   namespace electrodynamics {
   
   inline constexpr auto wavelength = isq::length;
   inline constexpr auto wavenumber = inverse(isq::length);
   
   inline constexpr auto frequency = inverse(isq::time);
   
   inline constexpr struct radiant_flux final : ::mp_units::quantity_spec<radiant_flux, isq::power> {} radiant_flux;
   inline constexpr struct QE final : ::mp_units::quantity_spec<QE, dimensionless> {} QE;
   
   inline constexpr struct radiant_intensity final :
           ::mp_units::quantity_spec<radiant_intensity, radiant_flux / angular::solid_angle> {}
   radiant_intensity;
   inline constexpr struct QE_solid_angle final :
           ::mp_units::quantity_spec<QE_solid_angle, QE * angular::solid_angle> {} QE_solid_angle;
   
   inline constexpr struct irradiance final :
           ::mp_units::quantity_spec<irradiance, radiant_flux / isq::area> {} irradiance;
   inline constexpr struct QE_area final :
           ::mp_units::quantity_spec<QE_area, QE * isq::area> {} QE_area;
   
   inline constexpr struct radiance final :
           ::mp_units::quantity_spec<radiance, radiant_flux / angular::solid_angle / isq::area> {}
   radiance;
   inline constexpr struct QE_solid_angle_area final :
           ::mp_units::quantity_spec<QE_solid_angle_area, QE * angular::solid_angle * isq::area> {} QE_solid_angle_area;
   
   }
   
   
   /* common spatial quantities
    */
   
   using length_t = quantity<isq::length[u::m]>;
   using length_density_t = quantity<inverse(length_t::reference)>;
   
   using area_t = quantity<isq::area[square(u::m)]>;
   using area_density_t = quantity<inverse(area_t::reference)>;
   
   using volume_t = quantity<isq::volume[pow<3>(u::m)]>;
   using volume_density_t = quantity<inverse(volume_t::reference)>;
   
   
   template<typename T>
   concept Length = QuantityOf<T, isq::length>;
   template<typename T>
   concept Area = QuantityOf<T, isq::area>;
   template<typename T>
   concept Volume = QuantityOf<T, isq::volume>;
   
   
   /* common angular quantities
    */
   
   using angle_t               = quantity<angular::angle[u::ang::rad]>;
   using angle_density_t       = quantity<inverse(angle_t::reference)>;
   using solid_angle_t         = quantity<angular::solid_angle[u::ang::sr]>;
   using solid_angle_density_t = quantity<inverse(solid_angle_t::reference)>;
   
   
   template<typename T>
   concept Angle = QuantityOf<T, angle_t::quantity_spec>;
   template<typename T>
   concept SolidAngle = QuantityOf<T, solid_angle_t::quantity_spec>;
   
   
   /* light and electrodynamics quantities
    */
   
   using frequency_t = quantity<electrodynamics::frequency[u::GHz]>;
   
   using wavelength_t = quantity<electrodynamics::wavelength[u::mm]>;
   using wavelength_density_t = quantity<inverse(wavelength_t::reference)>;
   using wavenumber_t = quantity<electrodynamics::wavenumber[u::one / u::mm]>;
   using wavenumber_density_t = quantity<inverse(wavenumber_t::reference)>;
   
   using power_t = quantity<isq::power[u::W]>;
   
   using radiant_flux_t = quantity<electrodynamics::radiant_flux[u::W]>;
   using spectral_radiant_flux_t = quantity<
       (electrodynamics::radiant_flux[u::W]) /
       (electrodynamics::wavenumber[u::one / u::mm])
   >;
   using QE_t = quantity<electrodynamics::QE[u::one]>;
   
   using radiant_intensity_t = quantity<electrodynamics::radiant_intensity[u::W / solid_angle_t::unit]>;
   using spectral_radiant_intensity_t = quantity<
       (electrodynamics::radiant_intensity[u::W / solid_angle_t::unit]) /
       (electrodynamics::wavenumber[u::one / u::mm])
   >;
   using QE_area_t = quantity<electrodynamics::QE_area[area_t::unit]>;
   
   using irradiance_t = quantity<electrodynamics::irradiance[u::W / area_t::unit]>;
   using spectral_irradiance_t = quantity<
       (electrodynamics::irradiance[u::W / area_t::unit]) /
       (electrodynamics::wavenumber[u::one / u::mm])
   >;
   using QE_solid_angle_t = quantity<electrodynamics::QE_solid_angle[solid_angle_t::unit]>;
   
   using radiance_t = quantity<electrodynamics::radiance[u::W / solid_angle_t::unit / area_t::unit]>;
   using spectral_radiance_t = quantity<
       (electrodynamics::radiance[u::W / solid_angle_t::unit / area_t::unit]) /
       (electrodynamics::wavenumber[u::one / u::mm])
   >;
   using QE_flux_t = quantity<
       electrodynamics::QE_solid_angle_area[solid_angle_t::unit * area_t::unit]
   >;
   
   
   template<typename T>
   concept Frequency = QuantityOf<T, frequency_t::quantity_spec>;
   template<typename T>
   concept Wavelength = QuantityOf<T, wavelength_t::quantity_spec>;
   template<typename T>
   concept Wavenumber = QuantityOf<T, wavenumber_t::quantity_spec>;
   
   
   /* common thermodynamic quantities
    */
   
   using temperature_t = quantity_point<
       isq::thermodynamic_temperature[u::K], 
       mp_units::default_point_origin(isq::thermodynamic_temperature[u::K]), 
       f_t
   >;
   
   
   template<typename T>
   concept Temperature = QuantityPointOf<T, temperature_t::quantity_spec>;
   
   
   /* shorthands for quantity to value conversions
    */
   
   namespace u {
   
   constexpr inline auto to_num(const QuantityOf<dimensionless> auto q) noexcept {
       return q.numerical_value_in(u::one);
   }
   
   constexpr inline auto to_nm(const QuantityOf<isq::length> auto q) noexcept {
       return q.numerical_value_in(u::nm);
   }
   
   constexpr inline auto to_mm(const QuantityOf<isq::length> auto q) noexcept {
       return q.numerical_value_in(u::mm);
   }
   
   constexpr inline auto to_µm(const QuantityOf<isq::length> auto q) noexcept {
       return q.numerical_value_in(u::µm);
   }
   
   constexpr inline auto to_m(const QuantityOf<isq::length> auto q) noexcept {
       return q.numerical_value_in(u::m);
   }
   
   constexpr inline auto to_mm2(const QuantityOf<isq::area> auto q) noexcept {
       return q.numerical_value_in(square(u::mm));
   }
   
   constexpr inline auto to_m2(const QuantityOf<isq::area> auto q) noexcept {
       return q.numerical_value_in(area_t::unit);
   }
   
   constexpr inline auto to_inv_m(const QuantityOf<inverse(isq::length)> auto q) noexcept {
       return q.numerical_value_in(u::one/u::m);
   }
   
   constexpr inline auto to_inv_mm(const QuantityOf<inverse(isq::length)> auto q) noexcept {
       return q.numerical_value_in(u::one / u::mm);
   }
   
   constexpr inline auto to_inv_m2(const QuantityOf<inverse(isq::area)> auto q) noexcept {
       return q.numerical_value_in(inverse(area_t::unit));
   }
   
   constexpr inline auto to_inv_mm2(const QuantityOf<inverse(isq::area)> auto q) noexcept {
       return q.numerical_value_in(inverse(square(u::mm)));
   }
   
   constexpr inline auto to_rad(const QuantityOf<angular::angle> auto q) noexcept {
       return q.numerical_value_in(u::ang::rad);
   }
   
   constexpr inline auto to_sr(const QuantityOf<angular::solid_angle> auto q) noexcept {
       return q.numerical_value_in(solid_angle_t::unit);
   }
   
   constexpr inline auto to_Hz(const QuantityOf<electrodynamics::frequency> auto q) noexcept {
       return q.numerical_value_in(u::Hz);
   }
   
   constexpr inline auto to_kHz(const QuantityOf<electrodynamics::frequency> auto q) noexcept {
       return q.numerical_value_in(u::kHz);
   }
   
   constexpr inline auto to_MHz(const QuantityOf<electrodynamics::frequency> auto q) noexcept {
       return q.numerical_value_in(u::MHz);
   }
   
   constexpr inline auto to_GHz(const QuantityOf<electrodynamics::frequency> auto q) noexcept {
       return q.numerical_value_in(u::GHz);
   }
   
   constexpr inline auto to_W(const QuantityOf<isq::power> auto q) noexcept {
       return q.numerical_value_in(u::W);
   }
   
   template <Unit U>
   constexpr inline auto numerical_value_in(const Quantity auto& q, const U u) noexcept {
       return q.numerical_value_in(u);
   }
   
   }
   
   }
