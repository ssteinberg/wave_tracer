
.. _program_listing_file__home_runner_work_wave_tracer_wave_tracer_include_wt_interaction_fsd_free_space_diffraction.hpp:

Program Listing for File free_space_diffraction.hpp
===================================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_wave_tracer_wave_tracer_include_wt_interaction_fsd_free_space_diffraction.hpp>` (``/home/runner/work/wave_tracer/wave_tracer/include/wt/interaction/fsd/free_space_diffraction.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
   *
   * wave tracer
   * Copyright  Shlomi Steinberg
   *
   * LICENSE: Creative Commons Attribution-NonCommercial 4.0 International
   *
   */
   
   #pragma once
   
   #include <vector>
   #include <optional>
   
   #include <wt/ads/ads.hpp>
   #include <wt/ads/intersection_record.hpp>
   #include <wt/sampler/sampler.hpp>
   
   #include <wt/math/common.hpp>
   #include <wt/sampler/density.hpp>
   
   #include <wt/interaction/intersection.hpp>
   
   #include <wt/interaction/fsd/common.hpp>
   
   namespace wt {
   
   class free_space_diffraction_t {
   private:
       utd::fsd_aperture_t aperture;
       pqvec3_t interaction_wp;
   
   public:
       struct sample_ret_t {
           pqvec3_t diffraction_wp;
           dir3_t wo = { 0,0,1 };
           // edge's surface
           std::optional<intersection_edge_t> intersection;
   
           // sampled a direct (passthrough) term
           bool is_direct;
   
           angle_sampling_pd_t dpd = angle_sampling_pd_t::discrete(0);
           f_t weight;
       };
   
       struct diffracting_edge_t {
           utd::UTD_ret_t utd;
           ads::tuid_t edge_idx;
           pqvec3_t p;
           dir3_t wi,wo;
           length_t ri, ro;
       };
       using eval_ret_t = std::vector<diffracting_edge_t>;
   
   public:
       free_space_diffraction_t(
               const ads::ads_t* ads,
               const pqvec3_t& interaction_wp,
               const frame_t&  interaction_region_frame,
               const pqvec3_t& interaction_region_size,
               const dir3_t& wi,
               wavenumber_t k,
               const ads::intersection_record_t::edges_container_t& edges) noexcept;
       free_space_diffraction_t(free_space_diffraction_t&&) noexcept = default;
   
       [[nodiscard]] bool empty() const noexcept { return aperture.edges.empty(); }
   
       [[nodiscard]] sample_ret_t sample(const ads::ads_t* ads,
                                         const pqvec3_t& src, sampler::sampler_t& sampler) const noexcept;
   
       [[nodiscard]] eval_ret_t f(const pqvec3_t& src, const pqvec3_t& dst) const noexcept;
   
       [[nodiscard]] angle_sampling_pd_t pdf(const pqvec3_t& src, const dir3_t& wo) const noexcept;
   };
   
   }
