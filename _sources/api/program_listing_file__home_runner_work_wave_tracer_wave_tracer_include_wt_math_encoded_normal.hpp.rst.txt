
.. _program_listing_file__home_runner_work_wave_tracer_wave_tracer_include_wt_math_encoded_normal.hpp:

Program Listing for File encoded_normal.hpp
===========================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_wave_tracer_wave_tracer_include_wt_math_encoded_normal.hpp>` (``/home/runner/work/wave_tracer/wave_tracer/include/wt/math/encoded_normal.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
   *
   * wave tracer
   * Copyright  Shlomi Steinberg
   *
   * LICENSE: Creative Commons Attribution-NonCommercial 4.0 International
   *
   */
   
   #pragma once
   
   #include <cassert>
   #include <wt/math/common.hpp>
   
   namespace wt {
   
   class encoded_normal_t {
   private:
       std::size_t enc{};
   
   private:
       static constexpr inline vec2_t vec2_oct_wrap(vec2_t v) noexcept {
           return (vec2_t{ 1 } - m::abs(vec2_t{ v.y,v.x }) ) * 
               (m::mix(vec2_t{ -1 }, vec2_t{ 1 }, v>=vec2_t{ 0 }));
       }
   
   public:
       encoded_normal_t() noexcept = default;
       explicit encoded_normal_t(dir3_t normal) noexcept {
           vec3_t n = vec3_t{ normal } / (m::abs(normal.x) + m::abs(normal.y) + m::abs(normal.z));
           auto xy = n.z>=0 ? vec2_t{ n } : vec2_oct_wrap(vec2_t{ n });
           xy = xy*f_t(.5) + f_t(.5);
   
           assert(m::isfinite(xy));
   
           *reinterpret_cast<vec2_t*>(&enc) = xy;
       }
   
       encoded_normal_t(encoded_normal_t&&) noexcept = default;
       encoded_normal_t(const encoded_normal_t&) noexcept = default;
       encoded_normal_t& operator=(encoded_normal_t&&) noexcept = default;
       encoded_normal_t& operator=(const encoded_normal_t&) noexcept = default;
   
       encoded_normal_t& operator=(const dir3_t& n) noexcept {
           *this = encoded_normal_t{ n };
           return *this;
       }
   
       explicit operator dir3_t() const noexcept {
           auto enc = *reinterpret_cast<const vec2_t*>(&this->enc);
           enc = enc*f_t(2) - vec2_t{ 1 };
   
           const auto z = 1 - m::abs(enc.x) - m::abs(enc.y);
           vec3_t n = {
               z>=0 ? enc : vec2_oct_wrap(enc),
               z
           };
           return m::normalize(n);
       }
   };
   
   }
