
.. _program_listing_file__home_runner_work_wave_tracer_wave_tracer_include_wt_bsdf_mask.hpp:

Program Listing for File mask.hpp
=================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_wave_tracer_wave_tracer_include_wt_bsdf_mask.hpp>` (``/home/runner/work/wave_tracer/wave_tracer/include/wt/bsdf/mask.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
    *
    * wave tracer
    * Copyright  Shlomi Steinberg
    *
    * LICENSE: Creative Commons Attribution-NonCommercial 4.0 International
    *
    */
   
   #pragma once
   
   #include <string>
   
   #include <wt/texture/texture.hpp>
   #include <wt/wt_context.hpp>
   
   #include "bsdf.hpp"
   
   namespace wt::bsdf {
   
   class mask_t final : public bsdf_t {
   private:
       std::shared_ptr<texture::texture_t> mask;
       std::shared_ptr<bsdf_t> nested;
   
       [[nodiscard]] inline auto lobe_null(const wavenumber_t k) const {
           const auto ls = nested->lobes(k);
           for (auto l=(int)ls.size()-1;;--l) {
               if (!ls.test(l))
                   return (std::uint32_t)l;
               if (l==0)
                   throw std::runtime_error("(mask bsdf) nested BSDF admits no empty lobes.");
           }
       }
   
   public:
       mask_t(std::string id, std::shared_ptr<texture::texture_t> mask, std::shared_ptr<bsdf_t> nested)
           : bsdf_t(std::move(id)), mask(std::move(mask)), nested(std::move(nested))
       {}
       mask_t(mask_t &&) = default;
   
       [[nodiscard]] frame_t shading_frame(
               const texture::texture_query_t& tquery,
               const mesh::surface_differentials_t& tangent_frame,
               const dir3_t& ns) const noexcept override {
           return nested->shading_frame(tquery, tangent_frame, ns);
       }
   
       [[nodiscard]] inline std::optional<f_t> albedo(const wavenumber_t k) const noexcept override {
           return nested->albedo(k);
       }
       
       [[nodiscard]] lobe_mask_t lobes(wavenumber_t k) const noexcept override {
           auto lobes = nested->lobes(k);
           lobes.set(lobe_null(k));
           return lobes;
       }
   
       [[nodiscard]] inline bool is_delta_only(const wavenumber_t k) const noexcept override {
           return nested->is_delta_only(k);
       }
       
       [[nodiscard]] inline bool is_delta_lobe(wavenumber_t k, std::uint32_t lobe) const noexcept override {
           if (lobe==lobe_null(k))
               return true;
           return nested->is_delta_lobe(k,lobe);
       }
       
       [[nodiscard]] inline bool needs_interaction_footprint() const noexcept override {
           return nested->needs_interaction_footprint() || mask->needs_interaction_footprint();
       }
   
       [[nodiscard]] bsdf_result_t f(
               const dir3_t &wi, 
               const dir3_t &wo,
               const bsdf_query_t &query) const noexcept override;
   
       [[nodiscard]] std::optional<bsdf_sample_t> sample(
               const dir3_t &wi, 
               const bsdf_query_t &query,
               sampler::sampler_t &sampler) const noexcept override;
   
       [[nodiscard]] solid_angle_density_t pdf(
               const dir3_t &wi, const dir3_t &wo,
               const bsdf_query_t &query) const noexcept override;
   
       [[nodiscard]] f_t eta(const dir3_t &wi, const dir3_t &wo,
                             const wavenumber_t k) const noexcept override {
           // no transmission on masked nested bsdf
           return 1;
       }
   
       [[nodiscard]] scene::element::info_t description() const override;
   
   public:
       static std::unique_ptr<bsdf_t> load(std::string id, scene::loader::loader_t* loader,
                                           const scene::loader::node_t& node,
                                           const wt::wt_context_t &context);
   };
   
   } // namespace wt::bsdf
