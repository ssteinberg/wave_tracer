
.. _program_listing_file__home_runner_work_wave_tracer_wave_tracer_include_wt_spectrum_composite.hpp:

Program Listing for File composite.hpp
======================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_wave_tracer_wave_tracer_include_wt_spectrum_composite.hpp>` (``/home/runner/work/wave_tracer/wave_tracer/include/wt/spectrum/composite.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
   *
   * wave tracer
   * Copyright  Shlomi Steinberg
   *
   * LICENSE: Creative Commons Attribution-NonCommercial 4.0 International
   *
   */
   
   #pragma once
   
   #include <string>
   #include <memory>
   #include <map>
   
   #include <wt/sampler/sampler.hpp>
   
   #include <wt/math/common.hpp>
   #include <wt/wt_context.hpp>
   
   #include "spectrum.hpp"
   
   namespace wt::spectrum {
   
   class composite_t final : public spectrum_real_t {
   private:
       struct comparator_rangew_t {
           bool operator()(const auto& a, const auto& b) const {
               return a.max<=b.min;
           }
       };
   
       using map_range_t = range_t<wavenumber_t, range_inclusiveness_e::left_inclusive>;
       using map_t = std::map<map_range_t, 
                              std::shared_ptr<spectrum_real_t>, 
                              comparator_rangew_t>;
   
   private:
       map_t spectra;
       range_t<wavenumber_t> range;
       wavenumber_t mean;
       f_t pwr;
   
   public:
       composite_t(std::string id,
                   map_t spectra)
           : spectrum_real_t(std::move(id)),
             spectra(std::move(spectra))
       {
           this->range = range_t<wavenumber_t>::null();
           f_t spectral_power = 0;
           wavenumber_t mean = 0/u::mm;
           for (const auto& s : this->spectra) {
               assert((this->range & s.first).empty());    // overlapping spectra?
               this->range |= s.first;
   
               const auto p = s.second->power(range_t<wavenumber_t>{ s.first.min,s.first.max });
   
               spectral_power += p;
               mean += s.second->mean_wavenumber() * p;
           }
   
           this->pwr = spectral_power;
           this->mean = spectral_power>0 ? mean / spectral_power : 0/u::mm;
       }
       composite_t(const composite_t&) = default;
       composite_t(composite_t&&) = default;
   
       [[nodiscard]] const distribution1d_t* distribution() const noexcept override {
           return nullptr;
       }
   
       [[nodiscard]] f_t power() const noexcept override {
           return pwr;
       }
   
       [[nodiscard]] f_t power(const range_t<wavenumber_t>& wavenumbers) const noexcept override {
           f_t spectral_power = 0;
           for (const auto& s : this->spectra) {
               const auto range = wavenumbers & s.first;
               spectral_power += s.second->power(range);
           }
   
           return spectral_power;
       }
   
       [[nodiscard]] range_t<wavenumber_t> wavenumber_range() const noexcept override {
           return range;
       }
       
       [[nodiscard]] wavenumber_t mean_wavenumber() const noexcept override {
           return mean;
       }
       
       [[nodiscard]] f_t f(const wavenumber_t wavenumber) const noexcept override {
           const auto it = spectra.lower_bound(map_range_t::range(wavenumber));
           if (it!=spectra.end() && it->first.contains(wavenumber))
               return it->second->f(wavenumber);
           return 0;
       }
       
   public:
       static std::unique_ptr<spectrum_real_t> load(std::string id, 
                                               scene::loader::loader_t* loader, 
                                               const scene::loader::node_t& node, 
                                               const wt::wt_context_t &context);
   
       [[nodiscard]] scene::element::info_t description() const override;
   };
   
   }
